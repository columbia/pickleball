"""Process a CSV generated by the analyze_traces.py script"""
import argparse
import csv
import matplotlib.pyplot as plt
from typing import List, Dict, Tuple
from collections import Counter

FILENAME = 'analyzed_766.csv'

# List of callables allowed by the _weights_only_unpickler in PyTorch.
ALLOWED_CALLABLES = [
    'from collections import OrderedDict',
    'from torch.nn.parameter import Parameter',
    'from torch.nn.serialization import _get_layout',
    'from torch import Size',
    'from torch import Tensor',

    'from torch import complex32',
    'from torch import complex64',
    'from torch import complex128',
    'from torch import float8_e5m2',
    'from torch import float8_e4m3fn',
    'from torch import float8_e5m2fnuz',
    'from torch import float8_e4m3fnuz',
    'from torch import float16',
    'from torch import float32',
    'from torch import float64',
    'from torch import int8',
    'from torch import int16',
    'from torch import int32',
    'from torch import int64',

    'from torch import DoubleStorage',
    'from torch import FloatStorage',
    'from torch import HalfStorage',
    'from torch import LongStorage',
    'from torch import IntStorage',
    'from torch import ShortStorage',
    'from torch import CharStorage',
    'from torch import ByteStorage',
    'from torch import BoolStorage',
    'from torch import BFloat16Storage',
    'from torch import ComplexDoubleStorage',
    'from torch import ComplexFloatStorage',
    'from torch import QInt8Storage',
    'from torch import QInt32Storage',
    'from torch import QUInt8Storage',
    'from torch import QUInt4x2Storage',
    'from torch import QUInt2x4Storage',

    'from torch._utils import _rebuild_parameter',
    'from torch._utils import _rebuild_tensor',
    'from torch._utils import _rebuild_tensor_v2',
    'from torch._utils import _rebuild_tensor_v3',
    'from torch._utils import _rebuild_sparse_tensor',
    'from torch._utils import _rebuild_meta_tensor_no_storage',
    'from torch._utils import _rebuild_nested_tensor',
]

VIOLATING_CALLABLES = []

class Model(object):

    def __init__(self, name: str, imports: List[str], extensions: List[str]):
        self.name: str = name
        self.imports: List[str] = imports
        self.extensions: List[str] = extensions


class Repository(object):

    def __init__(self, name: str, tags: List[str]):
        self.name: str = name
        self.tags: List[str] = tags
        self.models = []

    def add_model(self, model: Model):
        self.models.append(model)

    def get_model(self, model_name: str):
        return next(model for model in self.models if model.name == model_name)

def parse_row(row: List[str]) -> Repository:

    assert(len(row) > 1)

    repo = Repository(row[0], list(row[1]))
    models = row[2:]
    for i in range(0, len(models), 3):
        if (i + 2 < len(models)):
            name = models[i]
            imports = models[i+1].split(',')
            extensions = models[i+2].split(',')
            repo.add_model(Model(name, imports, extensions))
    return repo

def total_repositories(repositories: Dict[str, Repository]) -> int:
    return len(repositories)

def total_models(repositories: Dict[str, Repository]) -> int:
    total = 0
    for repo_name in repositories:
        total += len(repositories[repo_name].models)
    return total

def total_pytorch_bin_models(repositories: Dict[str, Repository]) -> int:
    total = 0
    for repo_name in repositories:
        total += int(sum(model.name.startswith('pytorch_model')
                for model
                in repositories[repo_name].models))
    return total

# List of the models that use imports other than those allowed by the weights_only_unpickler.
# Returned as a tuple in the format (repository name, model name).
def violating_models(repositories) -> List[Tuple[str, str]]:
    violating = []
    for repo_name in repositories:
        repo = repositories[repo_name]
        # Filter repo models for any that include an import that is not in the allowed_callables.
        for model in repo.models:
            for _callable in model.imports:
                if _callable not in ALLOWED_CALLABLES:
                    violating.append((repo_name, model.name))
                    VIOLATING_CALLABLES.append(_callable)
                    #print(f'{repo_name}:{model.name} - {_callable}')
                    break
    return violating

# List of repositories that contain at least one violating model
def violating_repos(violating_models: List[Tuple[str, str]]) -> List[str]:
    return list(set([x[0] for x in violating_models]))

def violating_models_pytorch(violating_models: Tuple[str, str]) -> List[Tuple[str, str]]:
    return list(filter(lambda violating_tuple: violating_tuple[1].startswith("pytorch_model"), violating_models))


def failed_downloads(repos: Dict[str, Repository]) -> List[str]:
    failures = []
    for repo_name in repos:
        if len(repos[repo_name].models) == 0:
            failures.append(repo_name)

    return failures

def read_repos(csv_filename=FILENAME) -> Dict[str, Repository]:

    repos: Dict[str, Repository] = {}

    with open(csv_filename, 'r') as fd:
        analyzed_lines = csv.reader(fd, delimiter='|')
        for row in analyzed_lines:
            repository: Repository = parse_row(row)
            repos[repository.name] = repository

    return repos

def get_callable(import_stmt: str) -> str:

    if not import_stmt:
        return ''

    parts = import_stmt.split()
    module = parts[1]
    submodule = parts[3]
    return(f"{module}.{submodule}")

def plot_counter_data(counter_data: Counter, title="Non-standard imports", filename="counter_chart.pdf") -> None:

    # Sort the Counter data by values in decreasing order
    sorted_data = counter_data.most_common()
    column_names, column_heights = zip(*sorted_data)  # Unzip into two lists

    # Creating the bar chart
    fig, ax = plt.subplots(figsize=(10, 6))
    bars = ax.bar(column_names, column_heights, color='skyblue', edgecolor='black')

    # Formatting the chart
    ax.set_xlabel("Items", fontweight="bold")
    ax.set_ylabel("Counts", fontweight="bold")
    ax.set_title(title, fontweight="bold")
    ax.set_xticklabels(column_names, rotation=45, ha="right", fontweight="bold")

    # Add the value of each bar above the bar
    for bar, height in zip(bars, column_heights):
        ax.text(bar.get_x() + bar.get_width() / 2, height, str(height),
                ha='center', va='bottom', fontweight="bold", color="black")

    # Adjust layout and save as a PDF
    plt.tight_layout()
    plt.savefig(filename, format="pdf", bbox_inches="tight")
    plt.close()

    print(f"Counter data chart saved as '{filename}'.")

def main():

    parser = argparse.ArgumentParser()
    parser.add_argument("csv_file")
    args = parser.parse_args()

    repos: Dict[str, Repository] = read_repos(args.csv_file)
    failures: List[str] = failed_downloads(repos)

    filtered_repos = {k: v for k, v in repos.items()
                      if k not in failures}
    repos = filtered_repos

    violations = violating_models(repos)
    violating_repositories = violating_repos(violations)
    pytorch_violations = violating_models_pytorch(violations)

    print(f'total repositories: {total_repositories(repos)}')
    print(f'failed analyses: {len(failures)} ({(len(failures) / total_repositories(repos)) * 100:.2f}%)')
    print(f'violating repositories: {len(violating_repositories)} ({(len(violating_repositories) / total_repositories(repos)) * 100:.2f}%)')
    #print(violating_repositories)

    #print(f'total models: {total_models(repos)}')
    #print(f'violating models: {len(violations)} ({(len(violations) / total_models(repos)) * 100:.2f}%)')
    #print(violations)

    #print(f'pytorch_model.bin models: {total_pytorch_bin_models(repos)}')
    #if total_pytorch_bin_models(repos) > 0:
    #    print(f'violating models (pytorch_model.bin): {len(pytorch_violations)} ({(len(pytorch_violations) / total_pytorch_bin_models(repos)) * 100:.2f}%)')
    #    print(f'violating pytorch_model.bin models: {[model[0] for model in pytorch_violations]}')

    #violating_callables = [get_callable(import_stmt) for import_stmt in VIOLATING_CALLABLES if import_stmt]
    #print(VIOLATING_CALLABLES)
    #violating_callables_counter = Counter(violating_callables)
    #print(f'number of violating callables: {len(list(violating_callables_counter.keys()))}')
    #print(violating_callables_counter)
    #plot_counter_data(violating_callables_counter)


if __name__ == '__main__':
    main()
