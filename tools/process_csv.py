"""Process a CSV generated by the analyze_traces.py script"""
import csv
from typing import List, Dict, Tuple

FILENAME = 'analyzed_766.csv'

# List of callables allowed by the _weights_only_unpickler in PyTorch.
ALLOWED_CALLABLES = [
    'from collections import OrderedDict',
    'from torch.nn.parameter import Parameter',
    'from torch.nn.serialization import _get_layout',
    'from torch import Size',
    'from torch import Tensor',

    'from torch import complex32',
    'from torch import complex64',
    'from torch import complex128',
    'from torch import float8_e5m2',
    'from torch import float8_e4m3fn',
    'from torch import float8_e5m2fnuz',
    'from torch import float8_e4m3fnuz',
    'from torch import float16',
    'from torch import float32',
    'from torch import float64',
    'from torch import int8',
    'from torch import int16',
    'from torch import int32',
    'from torch import int64',

    'from torch import DoubleStorage',
    'from torch import FloatStorage',
    'from torch import HalfStorage',
    'from torch import LongStorage',
    'from torch import IntStorage',
    'from torch import ShortStorage',
    'from torch import CharStorage',
    'from torch import ByteStorage',
    'from torch import BoolStorage',
    'from torch import BFloat16Storage',
    'from torch import ComplexDoubleStorage',
    'from torch import ComplexFloatStorage',
    'from torch import QInt8Storage',
    'from torch import QInt32Storage',
    'from torch import QUInt8Storage',
    'from torch import QUint4x2Storage',
    'from torch import QUInt2x4Storage',

    'from torch._utils import _rebuild_parameter',
    'from torch._utils import _rebuild_tensor',
    'from torch._utils import _rebuild_tensor_v2',
    'from torch._utils import _rebuild_tensor_v3',
    'from torch._utils import _rebuild_sparse_tensor',
    'from torch._utils import _rebuild_meta_tensor_no_storage',
    'from torch._utils import _rebuild_nested_tensor',
]

class Model(object):

    def __init__(self, name: str, imports: List[str], extensions: List[str]):
        self.name: str = name
        self.imports: List[str] = imports
        self.extensions: List[str] = extensions


class Repository(object):

    def __init__(self, name: str, tags: List[str]):
        self.name: str = name
        self.tags: List[str] = tags
        self.models = []

    def add_model(self, model: Model):
        self.models.append(model)

    def get_model(self, model_name: str):
        return next(model for model in self.models if model.name == model_name)

def parse_row(row: List[str]) -> Repository:

    assert(len(row) > 1)

    repo = Repository(row[0], list(row[1]))
    models = row[2:]
    for i in range(0, len(models), 3):
        if (i + 2 < len(models)):
            name = models[i]
            imports = models[i+1].split(',')
            extensions = models[i+2].split(',')
            repo.add_model(Model(name, imports, extensions))
    return repo

def total_repositories(repositories: Dict[str, Repository]) -> int:
    return len(repositories)

def total_models(repositories: Dict[str, Repository]) -> int:
    total = 0
    for repo_name in repositories:
        total += len(repositories[repo_name].models)
    return total

def total_pytorch_bin_models(repositories: Dict[str, Repository]) -> int:
    total = 0
    for repo_name in repositories:
        total += int(sum(model.name.startswith('pytorch_model') for model in repositories[repo_name].models))
    return total

# List of the models that use imports other than those allowed by the weights_only_unpickler.
# Returned as a tuple in the format (repository name, model name).
def violating_models(repositories) -> List[Tuple[str, str]]:
    violating = []
    for repo_name in repositories:
        repo = repositories[repo_name]
        # Filter repo models for any that include an import that is not in the allowed_callables.
        for model in repo.models:
            for _callable in model.imports:
                if _callable not in ALLOWED_CALLABLES:
                    violating.append((repo_name, model.name))
                    #print(f'{repo_name}:{model.name} - {_callable}')
                    break
    return violating


def violating_models_pytorch(violating_models: Tuple[str, str]) -> List[Tuple[str, str]]:
    return list(filter(lambda violating_tuple: violating_tuple[1].startswith("pytorch_model"), violating_models))


def process_repos(csv_filename=FILENAME) -> Dict[str, Repository]:

    repos: Dict[str, Repository] = {}

    with open(csv_filename, 'r') as fd:
        analyzed_lines = csv.reader(fd, delimiter='|')
        for row in analyzed_lines:
            repository: Repository = parse_row(row)
            repos[repository.name] = repository

    return repos


def main():

    repos: Dict[str, Repository] = process_repos(FILENAME)

    with open(FILENAME, 'r') as fd:
        analyzed_lines = csv.reader(fd, delimiter='|')
        for row in analyzed_lines:
            repository: Repository = parse_row(row)
            repos[repository.name] = repository

    violations = violating_models(repos)
    pytorch_violations = violating_models_pytorch(violations)

    print(f'total repositories: {total_repositories(repos)}')
    print(f'total models: {total_models(repos)}')
    print(f'violating models: {len(violations)}')

    print(f'pytorch_model.bin models: {total_pytorch_bin_models(repos)}')
    print(f'violating models (pytorch_model.bin): {len(pytorch_violations)}')

    print(f'violating pytorch_model.bin models: {[model[0] for model in pytorch_violations]}')

if __name__ == '__main__':
    main()
